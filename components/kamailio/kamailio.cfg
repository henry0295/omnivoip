#!KAMAILIO
#
# OmniVoIP Kamailio Configuration
# WebRTC Gateway + SIP Proxy for Contact Center
#

####### Global Parameters #########

debug=2
log_stderror=no
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
fork=yes
children=8

# Listen interfaces
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tls:0.0.0.0:5061
listen=tcp:0.0.0.0:8080

# Advertised address (public IP)
#!ifdef WITH_NAT
advertised_address="YOUR_PUBLIC_IP"
#!endif

# Aliases
alias="omnivoip.local"

# TLS configuration
enable_tls=yes
tls_port_no=5061

####### Modules Section ########

# Set module path
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Loading order
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

# WebRTC modules
loadmodule "xhttp.so"
loadmodule "websocket.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "tls.so"

# Authentication
loadmodule "auth.so"
loadmodule "auth_db.so"

# Database
loadmodule "db_postgres.so"

# Presence (optional)
#loadmodule "presence.so"
#loadmodule "presence_xml.so"

# Statistics
loadmodule "htable.so"
loadmodule "pike.so"

####### Setting module-specific parameters #######

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)

# ----- usrloc params -----
modparam("usrloc", "db_url", "DBURL")
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 0)

# ----- auth_db params -----
modparam("auth_db", "db_url", "DBURL")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", 0)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.local")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("nathelper", "force_socket", "udp:0.0.0.0:5060")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_tout_ms", 2000)
modparam("rtpengine", "rtpengine_retr", 5)

# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 1)
modparam("websocket", "ping_application_data", "WebRTC")

# ----- htable params -----
modparam("htable", "htable", "websockets=>size=4;autoexpire=7200;")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", 2)
modparam("acc", "log_missed_flag", 3)
modparam("acc", "failed_transaction_flag", 4)
modparam("acc", "db_flag", 2)
modparam("acc", "db_missed_flag", 3)
modparam("acc", "db_url", "DBURL")

####### Routing Logic ########

request_route {
    # per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    ### only initial requests (no To tag)

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    t_check_trans();

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(2); # do accounting
    }

    # Handle registrations
    route(REGISTRAR);

    if ($rU==$null) {
        # request with no Username in RURI
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # Dispatch requests to Asterisk
    route(ASTERISK);
}

# Wrapper for relaying requests
route[RELAY] {
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE|MESSAGE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per SIP request initial checks
route[REQINIT] {
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if (!sanity_check("1511", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Flood detection
    if (!pike_check_req()) {
        xlog("L_ALERT", "ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(websockets=>$si) = 1;
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (has_totag()) {
        # Sequential requests
        if (loose_route()) {
            route(DLGURI);
            if (is_method("BYE")) {
                setflag(2); # do accounting
                setflag(3); # for missed calls
            } else if (is_method("ACK")) {
                # ACK is forwarded statelessly
                route(NATMANAGE);
            } else if (is_method("NOTIFY")) {
                # Add Record-Route for in-dialog NOTIFY as per RFC 6665
                record_route();
            }
            route(RELAY);
        } else {
            if (is_method("SUBSCRIBE") && uri == myself) {
                # In-dialog SUBSCRIBE requests
                route(PRESENCE);
                exit;
            }
            if (is_method("ACK")) {
                if (t_check_trans()) {
                    # ACK without matching transaction -> ignore
                    route(RELAY);
                    exit;
                } else {
                    # ACK to a local transaction
                    exit;
                }
            }
            sl_send_reply("404","Not here");
        }
        exit;
    }
}

# RTPEngine media proxy control
route[RTPENGINE] {
    if (is_method("INVITE|UPDATE") && !has_totag()) {
        # New dialog - offer
        if ($proto =~ "ws") {
            # WebRTC to SIP
            rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/SAVPF RTP/AVP");
        } else {
            # SIP to WebRTC
            rtpengine_manage("replace-origin replace-session-connection ICE=force RTP/AVP RTP/SAVPF");
        }
    }
    
    if (is_method("ACK") && has_totag()) {
        # Answer
        if ($proto =~ "ws") {
            rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/SAVPF RTP/AVP");
        } else {
            rtpengine_manage("replace-origin replace-session-connection ICE=force RTP/AVP RTP/SAVPF");
        }
    }
    
    if (is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }
}

# Caller NAT detection route
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
    }
    return;
}

# NAT handling
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(6);
            }
        }
    }
    if (!(isflagset(5) || isbflagset(6)))
        return;

    if(nat_uac_test("8")) {
        rtpengine_manage("trust-address replace-origin replace-session-connection ICE=force");
    }
    
    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(6)) {
            if(is_first_hop())
                set_contact_alias();
        }
    }
    return;
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# Registrar route
route[REGISTRAR] {
    if (!is_method("REGISTER"))
        return;

    if(isflagset(5)) {
        setbflag(6);
    }

    # Authenticate
    if (!auth_check("$fd", "subscriber", "1")) {
        auth_challenge("$fd", "0");
        exit;
    }

    # User authenticated - remove auth header
    consume_credentials();

    # Save WebSocket connection
    if (proto == WS || proto == WSS) {
        $sht(websockets=>$si) = 1;
    }

    # Save location
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Route to Asterisk
route[ASTERISK] {
    # Send to Asterisk
    $du = "sip:asterisk:5060";
    
    # RTPEngine handling
    route(RTPENGINE);
    
    # NAT handling
    route(NATMANAGE);
    
    # Relay
    route(RELAY);
    exit;
}

# WebSocket handling
event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();
    
    if ($Rp != 8080) {
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    xlog("L_INFO", "HTTP Request Received\n");

    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade" && $rm =~ "GET") {
        # WebSocket upgrade
        if (ws_handle_handshake()) {
            exit;
        }
    }

    xhttp_reply("404", "Not Found", "", "");
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("L_INFO", "New branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
    route(RTPENGINE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "Incoming reply $rs from $du\n");
    
    if (status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
        route(RTPENGINE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }

    # Retry on 503
    if (t_check_status("503")) {
        if (t_check_status("503")) {
            # Retry after 3 seconds
            append_branch();
            t_relay();
        }
    }
}
